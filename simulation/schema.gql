define

name sub attribute,
    datatype string;

organisation-name sub name;

forename sub name;

surname sub name;

date-of-event sub attribute,
    abstract,
    datatype date;

start-date sub date-of-event,
    datatype date;

end-date sub date-of-event,
    datatype date;

date-of-birth sub date-of-event,
    datatype date;

date-of-marriage sub date-of-event,
    datatype date;

gender sub attribute,
    datatype string;

contracted-hours sub attribute,
    datatype double;

language sub attribute, 
    datatype string,
    regex "^(English|French|German|Cantonese|Hindi|Malaysian|Indonesian)$";

num-characters sub attribute,
    datatype long;

text-content sub attribute, 
    datatype string,
    has language,
    has num-characters;

annual-wage sub attribute,
    datatype double;

currency-code sub attribute,
    datatype string,
    regex "^(GBP|EUR|USD|INR|MYR|IDR)$";

currency sub attribute, 
    datatype string,
    regex "^(Great British Pound|Euro|American Dollar|Indian Rupee|Malaysian Ringgit|Indonesian Rupiah)$",
    has currency-code,
    plays currency-adoption_currency-adopted;

data-signed sub attribute,
    datatype date;

identifier sub attribute,
    datatype long;

membership-id sub identifier;

person sub entity,
    key identifier,
    has forename,
    has surname,
    has gender,
    has date-of-birth,
    plays employment_employee,
    plays employment_full-time-employee,
    plays employment_part-time-employee,
    plays volunteering_volunteer,
    plays studentship_student,
    plays parentship_parent,
    plays parentship_child,
    plays marriage_husband,
    plays marriage_wife,
    plays friendship_friend,
    plays born-in_child;

parentship sub relation,
    relates parentship_parent,  # Could have two parents playing parent in a single parentship for interesting cardinality
    relates parentship_child;

friendship sub relation,
    has start-date,
    has end-date,
    relates friendship_friend; # Could be N-ary, though in a real-world context this is imperfect

marriage sub relation,
    key identifier,
    has date-of-marriage,
    relates marriage_husband,
    relates marriage_wife,
    plays locates_located;

membership sub relation,
    abstract,
    key membership-id,
    relates membership_member,
    relates membership_group;

employment sub membership,
    relates employment_employee as membership_member,
    relates employment_part-time-employee as employment_employee,
    relates employment_full-time-employee as employment_employee,
    relates employment_employer as membership_group,
    # relates employment_employment-contract,
    # relates employment_profession,  # https://github.com/graknlabs/grakn/issues/5553
    
    # For wages in different currencies, either:
    # - subtype for the different currencies,
    # - add currency as attribute to implicit relation,
    #Â - model the wage as an entity,
    # The attribute on an implicit relation is a pattern we would like to stress-test
    has annual-wage, 
    has contracted-hours,
    # Nested relation
    plays locates_located;

# @has-annual-wage sub @has-attribute,
#     has currency;

studentship sub membership,
    relates studentship_student as membership_member,
    relates studentship_school as membership_group;

volunteering sub membership,
    relates volunteering_volunteer as membership_member,
    relates volunteering_cause as membership_group;

occupation sub entity,
    key name;
#    plays employment_profession;

organisation sub entity,
    abstract,
    has organisation-name;

company sub organisation,
    plays employment_employer;

university sub organisation,
    plays employment_employer,
    plays studentship_school;

charity sub organisation,
    plays volunteering_cause;

location sub entity,
    key name,
    plays location-hierarchy_superior,
    plays location-hierarchy_subordinate;

area sub location,
    plays born-in_place-of-birth;

city sub location,
    plays born-in_place-of-birth;

county sub location;

country sub location,
    plays currency-adoption_adopting-country;

state sub location;

continent sub location;

location-hierarchy sub relation,
    relates location-hierarchy_superior,
    relates location-hierarchy_subordinate;

locates sub relation,
    relates locates_location,
    relates locates_located;

# Transitive hierarchy
location-hierarchy-transitivity sub rule,
when {
    $lh1(location-hierarchy_superior: $a, location-hierarchy_subordinate: $b) isa location-hierarchy;
    $lh2(location-hierarchy_superior: $b, location-hierarchy_subordinate: $c) isa location-hierarchy;
}, then {
    (location-hierarchy_superior: $a, location-hierarchy_subordinate: $c) isa location-hierarchy;
};

born-in sub locates,
    relates born-in_place-of-birth as locates_location,
    relates born-in_child as locates_located;

# Transitive group membership
# Here we realise that it's common to say that when something takes place in a location it also takes place in the superior places. 
# This will lead to many rules of this kind. Can this be generified, and should it be?
born-in-transitivity sub rule,
when {
    $lh1(location-hierarchy_superior: $a, location-hierarchy_subordinate: $b) isa location-hierarchy;
    $bi(born-in_child: $p, born-in_place-of-birth: $b) isa born-in;
}, then {
    (born-in_child: $p, born-in_place-of-birth: $a) isa born-in;
};

legal-document sub entity,
    has data-signed,
    has text-content;

legal-contract sub legal-document;

employment-contract sub legal-contract,
    # plays employment_employment-contract,
    has contracted-hours;

currency-adoption sub relation,
    has start-date,
    has end-date,
    relates currency-adoption_adopting-country,
    relates currency-adoption_currency-adopted;

insert $x "Great British Pound" isa currency, has currency-code "GBP";
insert $x "Euro" isa currency, has currency-code "EUR";
insert $x "American Dollar" isa currency, has currency-code "USD";
insert $x "Indian Rupee" isa currency, has currency-code "INR";
insert $x "Malaysian Ringgit" isa currency, has currency-code "MYR";
insert $x "Indonesian Rupiah" isa currency, has currency-code "IDR";

